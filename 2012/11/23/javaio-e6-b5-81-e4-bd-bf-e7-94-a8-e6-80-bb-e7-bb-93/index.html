<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>JavaIO流使用总结 | Hear The Wind Sing</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="buaa,brisbane,qut,ivan,phd,it" />
  

  <meta name="description" content="Java IO的一般使用原则： 一、按数据来源（去向）分类： 1、是文件： FileInputStream, FileOutputStream, FileReader, FileWriter 2、是byte[]：ByteArrayInputStream, ByteArrayOutputStream 3、是Char[]: CharArrayReader, CharArrayWriter 4、是Str">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaIO流使用总结">
<meta property="og:url" content="http://www.ivivan.com/2012/11/23/javaio-e6-b5-81-e4-bd-bf-e7-94-a8-e6-80-bb-e7-bb-93/index.html">
<meta property="og:site_name" content="Hear The Wind Sing">
<meta property="og:description" content="Java IO的一般使用原则： 一、按数据来源（去向）分类： 1、是文件： FileInputStream, FileOutputStream, FileReader, FileWriter 2、是byte[]：ByteArrayInputStream, ByteArrayOutputStream 3、是Char[]: CharArrayReader, CharArrayWriter 4、是Str">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://zzqrj.iteye.com/images/icon_star.png">
<meta property="og:image" content="http://zzqrj.iteye.com/images/icon_star.png">
<meta property="og:image" content="http://zzqrj.iteye.com/images/icon_star.png">
<meta property="og:image" content="http://zzqrj.iteye.com/images/icon_star.png">
<meta property="og:image" content="http://zzqrj.iteye.com/images/icon_star.png">
<meta property="og:image" content="http://zzqrj.iteye.com/images/icon_star.png">
<meta property="og:image" content="http://zzqrj.iteye.com/images/icon_star.png">
<meta property="og:image" content="http://zzqrj.iteye.com/images/icon_star.png">
<meta property="og:image" content="http://zzqrj.iteye.com/images/icon_star.png">
<meta property="article:published_time" content="2012-11-23T22:28:00.000Z">
<meta property="article:modified_time" content="2023-03-27T05:55:20.585Z">
<meta property="article:author" content="Ivan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zzqrj.iteye.com/images/icon_star.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-41831109-2', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  

  


  

<meta name="generator" content="Hexo 6.3.0"></head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">L</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">L</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            S
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            T
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            M
          </a>
        </li>
      
    </ul>
  </div>


</div>




<div class="content content-post CENTER">
   <article id="post-javaio-e6-b5-81-e4-bd-bf-e7-94-a8-e6-80-bb-e7-bb-93" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">JavaIO流使用总结</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2012.11.23</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>Ivan</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/%E5%9B%BD%E5%A2%83%E4%BB%A5%E5%8D%97/">国境以南</a> / <a class="article-category-link" href="/categories/%E5%9B%BD%E5%A2%83%E4%BB%A5%E5%8D%97/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/">工作相关</a>
  </span>



      

      
      
    </div>
  </header>

  <div class="article-content">
    
      <p>Java IO的一般使用原则：</p>
<p>一、按数据来源（去向）分类：</p>
<p>1、是文件： FileInputStream, FileOutputStream, FileReader, FileWriter</p>
<p>2、是byte[]：ByteArrayInputStream, ByteArrayOutputStream</p>
<p>3、是Char[]: CharArrayReader, CharArrayWriter</p>
<p>4、是String: StringBufferInputStream, StringReader, StringWriter</p>
<p>5、网络数据流：InputStream, OutputStream, Reader, Writer</p>
<p>二、按是否格式化输出分：</p>
<p>1、要格式化输出：PrintStream, PrintWriter</p>
<p>三、按是否要缓冲分：</p>
<p>1、要缓冲：BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriter</p>
<p>四、按数据格式分：</p>
<p>1、二进制格式（只要不能确定是纯文本的）: InputStream, OutputStream及其所有带Stream结束的子类</p>
<p>2、纯文本格式（含纯英文与汉字或其他编码方式）；Reader, Writer及其所有带Reader, Writer的子类</p>
<p>五、按输入输出分：</p>
<p>1、输入：Reader, InputStream类型的子类</p>
<p>2、输出：Writer, OutputStream类型的子类</p>
<p>六、特殊需要：</p>
<p>1、从Stream到Reader,Writer的转换类：InputStreamReader, OutputStreamWriter</p>
<p>2、对象输入输出：ObjectInputStream, ObjectOutputStream</p>
<p>3、进程间通信：PipeInputStream, PipeOutputStream, PipeReader, PipeWriter</p>
<p>4、合并输入：SequenceInputStream</p>
<p>5、更特殊的需要：PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader</p>
<p>决定使用哪个类以及它的构造进程的一般准则如下（不考虑特殊需要）：</p>
<p><strong>第一，考虑最原始的数据格式是什么：是否为文本？</strong></p>
<p><strong>第二，是输入还是输出?</strong></p>
<p><strong>第三，是否需要转换流：InputStreamReader, OutputStreamWriter?</strong></p>
<p><strong>第四，数据来源（去向）是什么：文件？内存？网络？</strong></p>
<p><strong>第五，是否要缓冲：bufferedReader （特别注明：一定要注意的是readLine()是否有定义，有什么比read, write更特殊的输入或输出方法）</strong></p>
<p><strong>第六，是否要格式化输出：print?</strong></p>
<p><strong>总结二：</strong></p>
<p>首先是java的IO。这破东西可真费事，I&#x2F;O类库常使用”流(stream)”这种抽象。所谓”流”是一种能生成或接受数据的，代表数据的源和目标的对象。流把I&#x2F;O设备内部的具体操作给隐藏起来了。 正如JDK文档所显示的，Java的I&#x2F;O类库分成输入和输出两大部分。所有InputStream和Reader的派生类都有一个基本的，继承下来的，能读取单个或byte数组的read( )方法。同理，所有OutputStream和Writer的派生类都有一个基本的，能写入单个或byte数组的write( )方法。但通常情况下，你是不会去用这些方法的；它们是给其它类用的 —— 而后者会提供一些更实用的接口。因此，你很少会碰到只用一个类就能创建一个流的情形，实际上你得把多个对象叠起来，并以此来获取所需的功能。Java的流类库之所以会那么让人犯晕，最主要的原因就是”你必须为创建一个流而动用多个对象”。</p>
<p>**Java的IO类结构：<br>**根接口是InputStream&#x2F;OutputStream，充当数据源的IO类有FileInputStream &#x2F;FileOutputStream，ByteArrayInputStream&amp;#160; &#x2F; ByteArrayOutputStream&amp;#160; 等，充当装饰功能的IO类有BufferedInputStream&amp;#160; &#x2F;&amp;#160;&amp;#160; BufferedOutputStream，DataInputStream&amp;#160;&amp;#160; &#x2F;&amp;#160;&amp;#160; DataOutputStream等，<br>它们都是继承装饰接口FilterInputStream&#x2F;FilterOutputStream。<br>使用IO时，首先创建一个数据源IO，然后根据需要的功能创建装饰类IO，其构造函数的参数为已创建的数据源IO。<br>我们以创建一个具有缓冲的文件输入流为例，假定需要从磁盘读取文件“C:\log.txt”：<br>&#x2F;&#x2F; 创建一个FileInputStream:<br>FileInputStream fileInput &#x3D; new FileInputStream(”C:\log.txt”);<br>&#x2F;&#x2F; 创建一个BufferedInputStream:<br>BufferedInputStream bufferedInput &#x3D; new BufferedInputStream(fileInput);<br>&#x2F;&#x2F; 现在得到的bufferedInput即是具有缓冲的文件输入流<br>或者进一步简写如下：<br>InputStream input &#x3D; new BufferedInputStream(new FileInputStream(”C:\log.txt”));<br>&#x2F;&#x2F; 现在得到的input即是具有缓冲的文件输入流</p>
<p><strong>java.io.Reader 和 java.io.InputStream 区别</strong><br>java.io.Reader 和 java.io.InputStream 组成了 Java 输入类。Reader 用于读入16位字符，也就是 Unicode 编码的字符；而 InputStream 用于读入 ASCII 字符和二进制数据。<br>在 Java 中，有不同类型的 Reader 输入流对应于不同的数据源：<br>FileReader 用于从文件输入；<br>CharArrayReader 用于从程序中的字符数组输入；<br>StringReader 用于从程序中的字符串输入；<br>PipedReader 用于读取从另一个线程中的 PipedWriter 写入管道的数据。<br>相 应的也有不同类型的 InputStream 输入流对应于不同的数据 源：FileInputStream，ByteArrayInputStream，StringBufferInputStream，PipedInputStream。 另外，还有两种没有对应 Reader 类型的 InputStream 输入流：<br>Socket 用于套接字；<br>URLConnection 用于 URL 连接。<br>这两个类使用 getInputStream() 来读取数据。<br>相应的，java.io.Writer 和 java.io.OutputStream 也有类似的区别。</p>
<p>**1、Java技术支持两种数据类型的流<br>**InputStream和OutputStream：字节流。其它字节流都是InputStream或OutputStream的子类。<br>Reader和 Writer：字符流。其它字符流都是Reader或Writer的子类。</p>
<p><strong>2、节点流</strong><br>Java 2 SDK中有三种基本类型的节点：文件(file)、内存(memory)、管道(pipe)。</p>
<p><strong>3、过程流</strong><br>过程流在其它流之上，完成排序、变换等操作。过程流也被称做过滤流。<br>当你需要改变输入流的原始数据时，你可以将一个过滤输入流连接到一个原始的输入流上。<br>用过滤流将原始数据变换成你需要的格式。</p>
<p><strong>4、基本字节流类</strong><br>4.1、FileInputStream和FileOutputStream<br>这两个节点流用来操纵磁盘文件。这些类的构造函数允许你指定它们所连接的文件。<br>要构造一个FileInputStream，所关联的文件必须存在而且是可读的。<br>如果你要构造一个FileOutputStream而输出文件已经存在，则它将被覆盖。<br>FileInputStream infile &#x3D; new FileInputStream(”myfile.dat”);<br>FileOutputStream outfile &#x3D; new FileOutputStream(”results.dat”);<br>4.1、 BufferInputStream和BufferOutputStream<br>这些是过滤器流，它们可以提高I&#x2F;O操作的效率。<br>4.3、 PipedInputStream和PipedOutputStream<br>管道流用来在线程间进行通信。一个线程的PipedInputStream对象从另一个线程的PipedOutputStream对象读取输入。<br>要使管道流有用，必须有一个输入方和一个输出方。<br>4.4、 DataInputStream和DataOutputStream<br>这些过滤器通过流来读写Java基本类</p>
<p><strong>5、 基本字符流类</strong><br>图阐述了Reader和Writer字符流的体系结构。<br>5.1、InputStreamReader 和 OutputStreamWriter<br>用于字节流与字符流之间的转换接口。<br>当你构造一个InputStreamReader或OutputStreamWriter时，转换规则定义了16位Unicode和其它平台的特定表示之间的转换。<br>InputStreamReader从一个数据源读取字节，并自动将其转换成Unicode字符。<br>如果你特别声明，InputStreamReade会将字节流转换成其它种类的字符流。<br>OutputStreamWriter将字符的Unicode编码写到输出流，如果你的使用的不是Unicode字符，OutputStreamWriter会将你的字符编码转换成Unicode编码。<br>5.2.、缓冲读者和作者<br>因为在各种格式之间进行转换和其它I&#x2F;O操作很类似，所以在处理大块数据时效率最高。<br>在InputStreamReader和OutputStreamWriter的结尾链接一个BufferedReader和BufferedWriter是一个好主意。<br>记住对BufferedWriter使用flush()方法。<br>5.3、 使用其它字符转换<br>如果你需要从一个非本地(例如，从连接到一个不同类型的机器的网络连接读取)的字符编码读取输入，<br>你可以象下面这个程序那样，使用显式的字符编码构造ir&#x3D;new InputStreamReader(System.in,&amp;#160; “8859_1″);<br>注：如果你通过网络连接读取字符，就应该使用这种形式。<br>否则，你的程序会总是试图将所读取的字符当作本地表示来进行转换，而这并不总是正确的。ISO 8859-1是映射到ASCII的Latin-1编码模式。</p>
<p><strong>6、 对象串行化</strong><br>java.io.Serializable接口支持将一个Java技术对象存放到一个流中。<br>将一个对象存放到某种类型的永久存储器上称为”保持”。<br>如果一个对象可以被存放到磁盘或磁带上，或者可以发送到另外一台机器并存放到存储器或磁盘上，那么这个对象就被称为可保持的。<br>java.io.Serializable接口没有任何方法，它只作为一个”标记”，用来表明实现了这个接口的类可以串行化。<br>类中没有实现Serializable接口的对象不能被保持。<br>&#x2F;&#x2F; 文件实现追加：<br>&#x2F;&#x2F; 其中的FileWriter()中的第二个参数的含义是:是否在文件中追加内容<br>PrintWriter out &#x3D; new PrintWriter(new FileWriter(logFileName, true), true);<br>Java读写文件最常用的类是FileInputStream&#x2F;FileOutputStream和FileReader&#x2F;FileWriter。<br>其中FileInputStream和FileOutputStream是基于字节流的，常用于读写二进制文件。<br>读写字符文件建议使用基于字符的FileReader和FileWriter，省去了字节与字符之间的转换。<br>但这两个类的构造函数默认使用系统的编码方式，如果文件内容与系统编码方式不一致，可能会出现乱码。<br>在这种情况下，建议使用FileReader和FileWriter的父类：InputStreamReader&#x2F;OutputStreamWriter，<br>它们也是基于字符的，但在构造函数中可以指定编码类型：InputStreamReader(InputStream in, Charset cs) 和OutputStreamWriter(OutputStream out, Charset cs)。</p>
<p>&#x2F;&#x2F; 读写文件的编码：<br>InputStreamReader r &#x3D; new InputStreamReader(new FileInputStream(fileName), “utf-8″);<br>OutputStreamWriter out &#x3D; new OutputStreamWriter(new FileOutputStream(fileName),”utf-8″);</p>
<p><strong>&#x2F;</strong><br>三种IO性能比较:<br>在读写一个10k文件的时候，三种方式的耗时如下:<br>InputStreamReader And OutputStreamWriter : 63ms (可以设置文件的编码，如果不用buffer)<br>BufferedReader And BufferedWriter : 31ms<br>BufferedInputStream And BufferedOutputStream : 16ms<br><em>&#x2F;</em>*</p>
<p>&#x2F;**   </p>
<ul>
<li>Description: Test the java IO’s efficiency    </li>
<li>Author: AllanCao    </li>
<li>Date: 2007-02-18<br><em>&#x2F;<br>import java.io.</em>;</li>
</ul>
<p>&#x2F;**   </p>
<ul>
<li><strong>using the InputStreamReader And OutputStreamWriter</strong><br>*&#x2F;<br>class EncoderRW {<br>public static String read(String fileName) throws IOException {<br>StringBuffer sb &#x3D; new StringBuffer();<br>&#x2F;<em>此处读文件时用了buffer，如果不用，性能损失一倍</em>&#x2F;<br>BufferedReader in &#x3D; new BufferedReader(new InputStreamReader(new FileInputStream(fileName), “utf-8″));<br>String s;<br>while((s &#x3D; in.readLine()) !&#x3D; null) {<br>sb.append(s);<br>sb.append(”\n”);<br>}<br>in.close();<br>return sb.toString();<br>}<br>public void write(String fileName, String text) throws IOException {<br>OutputStreamWriter out &#x3D; new OutputStreamWriter(new FileOutputStream(fileName),”utf-8″);<br>out.write(text);<br>out.flush();<br>out.close();<br>}<br>}</li>
</ul>
<p>&#x2F;**   </p>
<ul>
<li>**using the BufferedReader And BufferedWriter<br>***&#x2F;<br>class WriterReader {<br>public String read(String fileName) throws IOException {<br>StringBuffer sb &#x3D; new StringBuffer();<br>BufferedReader in &#x3D; new BufferedReader(new FileReader(fileName));<br>String s;<br>while((s &#x3D; in.readLine()) !&#x3D; null) {<br>sb.append(s);<br>sb.append(”\n”);<br>}<br>in.close();<br>return sb.toString();<br>}<br>public void write(String fileName, String text) throws IOException {<br>PrintWriter out &#x3D; new PrintWriter(new BufferedWriter(new FileWriter(fileName)));<br>out.print(text);<br>out.close();<br>}<br>}</li>
</ul>
<p>&#x2F;**   </p>
<ul>
<li><strong>using the BufferedInputStream And BufferedOutputStream</strong><br>*&#x2F;<br>class BufferedStream{<br>public byte[] read(String fileName) throws IOException {<br>BufferedInputStream remoteBIS &#x3D; new BufferedInputStream(new FileInputStream(fileName));<br>ByteArrayOutputStream baos &#x3D; new ByteArrayOutputStream(10240);<br>byte[] buf &#x3D; new byte[1024];<br>int bytesRead &#x3D; 0;<br>while(bytesRead &gt;&#x3D; 0)<br>{<br>baos.write(buf, 0, bytesRead);<br>bytesRead &#x3D; remoteBIS.read(buf);<br>}<br>byte[] content &#x3D; baos.toByteArray();<br>return content;<br>}<br>public void write(String fileName, byte[] content)&amp;#160; throws IOException {<br>BufferedOutputStream out &#x3D; new BufferedOutputStream(new FileOutputStream(fileName));<br>out.write(content);<br>out.flush();<br>out.close();<br>}<br>}</li>
</ul>
<p>public class TestIO<br>{<br>public static void main(String[] args)throws IOException {<br>long currentTime &#x3D; System.currentTimeMillis() ;<br>EncoderRW rw &#x3D; new EncoderRW();<br>rw.write(”index.dat”,rw.read(”FileUtil.java”));<br>System.out.println(”cost time:” + Long.toString(System.currentTimeMillis()-currentTime) + ” ms”);</p>
<p>currentTime &#x3D; System.currentTimeMillis() ;<br>WriterReader wr &#x3D; new WriterReader();<br>wr.write(”index.dat”,wr.read(”FileUtil.java”));<br>System.out.println(”cost time:” + Long.toString(System.currentTimeMillis()-currentTime) + ” ms”);</p>
<p>currentTime &#x3D; System.currentTimeMillis() ;<br>BufferedStream bf &#x3D; new BufferedStream();<br>bf.write(”index.dat”,bf.read(”FileUtil.java”));<br>System.out.println(”cost time:” + Long.toString(System.currentTimeMillis()-currentTime) + ” ms”);<br>}<br>}</p>
<p>&amp;#160;</p>
<p><strong>一、基本概念</strong></p>
<p><strong>1. 概述</strong></p>
<p>&amp;#160;&amp;#160;&amp;#160; 使用IO时，首先创建一个数据源IO，然后根据需要，创建装饰类IO。</p>
<p><strong>2. Java IO的使用原则</strong></p>
<p>**决定使用哪个类以及它的构造进程的一般准则如下（不考虑特殊需要） **<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 第一，考虑最原始的数据格式是什么：是否为文本？<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 第二，是输入还是输出?<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 第三，是否需要转换流：InputStreamReader, OutputStreamWriter?<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 第四，数据来源（去向）是什么：文件？内存？网络？<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 第五，是否要缓冲：bufferedReader （特别注明：一定要注意的是readLine()是否有定义，有什么比read, write更特殊的输入或输出方法）<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 第六，是否要格式化输出：print?</p>
<p><strong>(1) 按数据来源（去向）分类</strong><br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 是文件： FileInputStream, FileOutputStream, FileReader, FileWriter<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 是byte[]：ByteArrayInputStream, ByteArrayOutputStream<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 是Char[]: CharArrayReader, CharArrayWriter<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 是String: StringBufferInputStream, StringReader, StringWriter<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 网络数据流：InputStream, OutputStream, Reader, Writer</p>
<p><strong>(2) 按是否格式化输出分</strong><br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 要格式化输出：PrintStream, PrintWriter</p>
<p>**(3) 按是否要缓冲分 **<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 要缓冲：BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriter</p>
<p>**(4) 按数据格式分 **<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 二进制格式（只要不能确定是纯文本的）: InputStream, OutputStream及其所有带Stream结束的子类<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 纯文本格式（含纯英文与汉字或其他编码方式）；Reader, Writer及其所有带Reader, Writer的子类</p>
<p>**(5) 按输入输出分 **<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 输入：Reader, InputStream类型的子类<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 输出：Writer, OutputStream类型的子类</p>
<p>**(6) 特殊需要 **<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 从Stream到Reader,Writer的转换类：InputStreamReader, OutputStreamWriter<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 对象输入输出：ObjectInputStream, ObjectOutputStream<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 进程间通信：PipeInputStream, PipeOutputStream, PipeReader, PipeWriter<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 合并输入：SequenceInputStream<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; - 更特殊的需要：PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader</p>
<p><strong>二、 例子代码</strong></p>
<p><strong>1.文件操作</strong></p>
<p><strong>(1) 从文件读</strong></p>
<p><strong>- 字节流</strong></p>
<p>**FileInputStream 的read方法 **: throws IOException<br>int read()读取单个字节<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; int read(byte[] b)从输入流中将最多 b.length 个字节的数据读入到 byte 数组中<br>b - 存储读取数据的缓冲区。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 返回：读入缓冲区的字节总数，如果到达文件末尾而没有更多的数据，返回 -1<br>int read(byte[] b, int off,int len)读取len个字节到字节数组b中的指定位置<br>b - 目标缓冲区。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; off - 开始存储字节处的偏移量。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; len - 要读取的最大字节数。</p>
<p>Java代码 <a target="_blank" rel="noopener" href="http://zzqrj.iteye.com/blog/"><img src="http://zzqrj.iteye.com/images/icon_star.png" alt="收藏代码"></a></p>
<ol>
<li>&#x2F;&#x2F;1. 以字节为单位读取文件内容，一次读一个字节</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; FileInputStream in &#x3D; new FileInputStream(file);&amp;#160;3.  int temp;&amp;#160;4.  while ((temp &#x3D; in.read()) !&#x3D; -1) {&#x2F;&#x2F;将读取的字节赋值给temp</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.write(temp);&amp;#160;6.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }&amp;#160;7.  &amp;#160;&amp;#160;&amp;#160; in.close();&amp;#160;8.9.  &#x2F;&#x2F;2. 以字节为单位读取文件内容，一次读多个字节</li>
<li>int byteread &#x3D; 0;&amp;#160;11.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; FileInputStream in &#x3D; new FileInputStream(fileName);&amp;#160;12.  byte[] tempbytes &#x3D; new byte[in.available()];&#x2F;&#x2F; 一次读多个字节</li>
<li>&#x2F;&#x2F; 读入多个字节到字节数组中，byteread为一次读入的字节数</li>
<li>while ((byteread &#x3D; in.read(tempbytes)) !&#x3D; -1) {&amp;#160;15.  &#x2F;&#x2F; String s&#x3D;new String(tempbytes,&quot;UTF-8&quot;);</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.write(tempbytes, 0, byteread);&amp;#160;17.  &amp;#160;&amp;#160;&amp;#160; }&amp;#160;</li>
</ol>
<p>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; &#x2F;&#x2F;3. 带缓冲的读文件&amp;#160;&amp;#160;&amp;#160; BufferedInputStream 只有read方法,没有readLine方法</p>
<p><strong>BufferedInputStream的read方法</strong> ：throws IOException<br>int read()读取单个字节<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; int read(byte[] b)从输入流中将最多 b.length 个字节的数据读入到 byte 数组中<br>&amp;#160; b - 存储读取数据的缓冲区。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 返回：读入缓冲区的字节总数，如果到达文件末尾而没有更多的数据，返回 -1<br>int read(byte[] b, int off,int len)读取len个字节到字节数组b中的指定位置<br>b - 目标缓冲区。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; off - 开始存储字节处的偏移量。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; len - 要读取的最大字节数。</p>
<p>Java代码 <a target="_blank" rel="noopener" href="http://zzqrj.iteye.com/blog/"><img src="http://zzqrj.iteye.com/images/icon_star.png" alt="收藏代码"></a></p>
<ol>
<li>byte[] data &#x3D; new byte[10];&amp;#160;2.  BufferedInputStream bis &#x3D; new BufferedInputStream(&amp;#160;3.  new FileInputStream(&quot;C:\readFile.txt&quot;));&amp;#160;4.  BufferedOutputStream bos &#x3D; new BufferedOutputStream(&amp;#160;5.  new FileOutputStream(&quot;C:\saveFile.txt&quot;));&amp;#160;6.  while (bis .read(data) !&#x3D; -1) bos.write(data);&amp;#160;7.  &#x2F;&#x2F; 将缓冲区中的资料全部写出</li>
<li>bos.flush();&amp;#160;</li>
</ol>
<p><strong>- 字符流</strong></p>
<p>**FileReader的read方法： **<br>int read()读取单个字节<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; int read(byte[] b)从输入流中将最多 b.length 个字节的数据读入到 byte 数组中<br>b - 存储读取数据的缓冲区。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 返回：读入缓冲区的字节总数，如果到达文件末尾而没有更多的数据，返回 -1<br>int read(byte[] b, int off,int len)读取len个字节到字节数组b中的指定位置<br>b - 目标缓冲区。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; off - 开始存储字节处的偏移量。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; len - 要读取的最大字节数。</p>
<p>Java代码 <a target="_blank" rel="noopener" href="http://zzqrj.iteye.com/blog/"><img src="http://zzqrj.iteye.com/images/icon_star.png" alt="收藏代码"></a></p>
<ol>
<li>&#x2F;&#x2F;1.一次读多个字符 read(byte[] b)</li>
<li>char data[] &#x3D; new char[10];&#x2F;&#x2F;建立可容纳10个字符的数组</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; FileReader fr &#x3D; new FileReader(&quot;algorithms.xml&quot;);&amp;#160;4.  int num &#x3D; fr.read(data);&#x2F;&#x2F; 将数据读入字符列表data内</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; String str &#x3D; new String(data, 0, num);&#x2F;&#x2F; 将字符列表转换成字符串</li>
<li>&amp;#160;&amp;#160;&amp;#160; fr.close();&amp;#160;7.8.  &#x2F;&#x2F;2.一次读多个字符&amp;#160; read(byte[] b, int off,int len)</li>
<li>File fileName&#x3D;new File(&quot;d:\temp\save.txt&quot;);&amp;#160;10.  char data[] &#x3D; new char[(int)fileName.length()];&#x2F;&#x2F;根据文件长度建立数组</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; FileReader fr &#x3D; new FileReader(fileName);&amp;#160;12.  int num &#x3D; fr.read(data,4,6);&#x2F;&#x2F;从文件中读6个字符放到data数组中，起始位置为data[4]&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; &#x2F;&#x2F;返回值num为从文件中读取字符的长度，即6&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;13.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; String str &#x3D; new String(data, 0, num);&#x2F;&#x2F; 将字符列表转换成字符串</li>
<li>&amp;#160;&amp;#160;&amp;#160; fr.close();&amp;#160;</li>
</ol>
<p>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; &#x2F;&#x2F;3. 带缓冲的读文件</p>
<p>**BufferedReader的read方法： <strong>增加了一个</strong>readLine() **方法throws IOException<br>int&amp;#160;&amp;#160;&amp;#160; read() 读取单个字符。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; int read(char[] cbuf, int off, int len) 将字符读入数组的某一部分。<br>&amp;#160; cbuf - 目标缓冲区<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; off - 开始存储字符处的偏移量<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; len - 要读取的最大字符数<br>String readLine() 读取一个文本行。</p>
<p>Java代码 <a target="_blank" rel="noopener" href="http://zzqrj.iteye.com/blog/"><img src="http://zzqrj.iteye.com/images/icon_star.png" alt="收藏代码"></a></p>
<ol>
<li>&#x2F;&#x2F;以行为单位从一个文件读取数据, BufferedReader 有read方法和readLine方法</li>
<li>BufferedReader in &#x3D; new BufferedReader( new FileReader(&quot;F:\TestIO.java&quot;));&amp;#160;3.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; String s&#x3D;null;&amp;#160;4.  while((s &#x3D; in.readLine()) !&#x3D; null) {&amp;#160;5.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; s+&#x3D;&quot;\n&quot;;&amp;#160;6.  System.out.print(s);&amp;#160;7.  }&amp;#160;8.  in.close();&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;</li>
</ol>
<p><strong>(2) 写文件</strong></p>
<p><strong>- 字节流</strong></p>
<p>**FileOutputStream的write方法： **throws IOException&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; </p>
<p>void write(int b)将指定字节b写入文件<br>b - 要写入的字节<br>void write(byte[] b)将b.length 个字节从指定 byte 数组写入此文件输出流中<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; void write(byte[] b,int off,int len)将byte数组中从偏移off开始的len个字节写入文件输出流<br>b - 数据<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; off - 数据中的起始偏移量<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; len - 要写入的字节数</p>
<p>Java代码 <a target="_blank" rel="noopener" href="http://zzqrj.iteye.com/blog/"><img src="http://zzqrj.iteye.com/images/icon_star.png" alt="收藏代码"></a></p>
<ol>
<li>&#x2F;&#x2F;1. 不带缓冲的写文件</li>
<li>byte b[]&#x3D;new byte[512];&amp;#160;3.  int count&#x3D;System.in.read(b); &#x2F;&#x2F;从键盘读取一行字符(写一个读一个，最大读取512个，回车读取结束)，存储到缓冲区</li>
<li>boolean a &#x3D; true;&#x2F;&#x2F;true表示追加，false表示覆盖</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; FileOutputStream fos &#x3D; new FileOutputStream(&quot;C:\saveFile.txt&quot;, a);&amp;#160;6.  fos.write(b);&#x2F;&#x2F;把缓冲区b的内容写到指定的文件中</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; fos.close();&amp;#160;</li>
</ol>
<p>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; &#x2F;&#x2F;2. 带缓冲的写文件 见文件操作(读)</p>
<p>**BufferedOutputStream的方法： **throws IOException<br>void write(int b)将指定字节b写入文件<br>b - 要写入的字节<br>void write(byte[] b)将b.length 个字节从指定 byte 数组写入此文件输出流中<br>void write(byte[] b,int off,int len)将byte数组中从偏移off开始的len个字节写入文件输出流<br>b - 数据<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; off - 数据中的起始偏移量<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; len - 要写入的字节数<br>void flush()刷新此缓冲的输出流，迫使所有缓冲的输出字节被写出到底层输出流中</p>
<p><strong>- 字符流</strong></p>
<p>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; &#x2F;&#x2F;1. 不带缓冲的写文件<br>**FileWriter的write方法： **throws IOException<br>void write(int b)将指定字节b写入文件<br>b - 要写入的字节<br>void write(byte[] b)将b.length 个字节从指定 byte 数组写入此文件输出流中<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; void write(byte[] b,int off,int len)将byte数组中从偏移off开始的len个字节写入文件输出流<br>b - 数据<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; off - 数据中的起始偏移量<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; len - 要写入的字节数</p>
<p>Java代码 <a target="_blank" rel="noopener" href="http://zzqrj.iteye.com/blog/"><img src="http://zzqrj.iteye.com/images/icon_star.png" alt="收藏代码"></a></p>
<ol>
<li>FileReader fr &#x3D; null;&amp;#160;2.  FileWriter fw &#x3D; null;&amp;#160;3.  int bi;&amp;#160;4.  fr &#x3D; new FileReader(&quot;d:\temp\read.txt&quot;);&amp;#160;5.  fw &#x3D; new FileWriter(&quot;d:\temp\save1.txt&quot;);&amp;#160;6.  while ((bi &#x3D; fr.read()) !&#x3D; -1) {&amp;#160;7.  &amp;#160;&amp;#160;&amp;#160; fw.write(bi);&#x2F;&#x2F;一次读一个字符(一个汉字字符占两个字节，一个英文字符占一个字节)</li>
<li>}&amp;#160;9.  fr.close();&amp;#160;10.  fw.close();&amp;#160;</li>
</ol>
<p>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; &#x2F;&#x2F;2. 带缓冲的写文件<br>**BufferedWriter的方法： **throws IOException<br>void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; void write(int c) 写入单个字符。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; void write(String s, int off, int len) 写入字符串的某一部分<br>s - 要写入的字符串<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; off - 开始读取字符处的偏移量<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; len - 要写入的字符数<br>void newLine() 写入一个行分隔符。行分隔符字符串由系统属性 line.separator 定义，并且不一定是单个新行 (‘\n’) 符<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; void flush()刷新此缓冲的输出流，迫使所有缓冲的输出字节被写出到底层输出流中</p>
<p>Java代码 <a target="_blank" rel="noopener" href="http://zzqrj.iteye.com/blog/"><img src="http://zzqrj.iteye.com/images/icon_star.png" alt="收藏代码"></a></p>
<ol>
<li>public class BufferedReaderWriterDemo {&amp;#160;2.  public static void main(String[] args) {&amp;#160;3.  try {&amp;#160;4.  &#x2F;&#x2F; 缓冲System.in输入流</li>
<li>&#x2F;&#x2F; System.in是位流，可以通过InputStreamReader将其转换为字符流</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; BufferedReader bufReader &#x3D; new BufferedReader(&amp;#160;7.  new InputStreamReader(System.in));&amp;#160;8.  &#x2F;&#x2F; 缓冲FileWriter</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; BufferedWriter bufWriter &#x3D; new BufferedWriter(new FileWriter(&amp;#160;10.  &quot;F:\saveFile.txt&quot;));&amp;#160;11.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; String input &#x3D; null;&amp;#160;12.  &#x2F;&#x2F; 每读一行进行一次写入动作</li>
<li>while (!(input &#x3D; bufReader.readLine()).equals(&quot;quit&quot;)) {&amp;#160;14.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bufWriter.write(input);&amp;#160;15.  &#x2F;&#x2F; newLine()方法写入与操作系统相依的换行字符，依执行环境当时的OS来决定该输出那种换行字符</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bufWriter.newLine();&amp;#160;17.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }&amp;#160;18.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bufReader.close();&amp;#160;19.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bufWriter.close();&amp;#160;20.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } catch (ArrayIndexOutOfBoundsException e) {&amp;#160;21.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(&quot;没有指定文件&quot;);&amp;#160;22.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } catch (IOException e) {&amp;#160;23.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; e.printStackTrace();&amp;#160;24.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }&amp;#160;25.  &amp;#160;&amp;#160;&amp;#160; }&amp;#160;26.  }&amp;#160;</li>
</ol>
<p><strong>2. 内存读写</strong></p>
<p>ByteArrayInputStream和ByteArrayOutputStream是将位数组当作流输入来源、输出目的地的类。<br>CharArrayReader和CharArrayWriter将字符数组当作字符数据输入输出的来源和目的</p>
<p>**ByteArrayInputStream的方法： **throws IOException<br>构造函数：ByteArrayInputStream(byte[] buf)<br>创建一个 ByteArrayInputStream，使用 buf 作为其缓冲区数组。<br>ByteArrayInputStream(byte[] buf, int offset, int length)<br>创建 ByteArrayInputStream，使用 buf 作为其缓冲区数组。<br>buf - 输入缓冲区。<br>offset - 缓冲区中要读取的第一个字节的偏移量。<br>length - 从缓冲区中读取的最大字节数。<br>int read()读取单个字节<br>int read(byte[] b)从输入流中将最多 b.length 个字节的数据读入到 byte 数组中<br>b - 存储读取数据的缓冲区。<br>返回：读入缓冲区的字节总数，如果到达文件末尾而没有更多的数据，返回 -1<br>int read(byte[] b, int off,int len)读取len个字节到字节数组b中的指定位置<br>b - 目标缓冲区。<br>off - 开始存储字节处的偏移量。<br>len - 要读取的最大字节数。<br>**ByteArrayOutputStream的方法： **<br>byte[]&amp;#160; toByteArray()<br>创建一个新的 byte 数组，大小是此输出流的当前大小，并且缓冲区的有效内容已复制到该数组中。<br>String toString() 使用平台默认的字符集，通过解码字节将缓冲区内容转换为字符串。<br>String toString(String charsetName)<br>使用指定的 charsetName，通过解码字节将缓冲区内容转换为字符串。<br>void write(byte[] b, int off, int len)<br>将byte数组中从偏移量off开始的len个字节写入此byte数组输出流。<br>b - 数据。<br>off - 数据的初始偏移量。<br>len - 要写入的字节数。<br>void write(int b) 将指定的字节写入此 byte 数组输出流。<br>void writeTo(OutputStream out) 将此 byte 数组输出流的全部内容写入到指定的输出流参数中。</p>
<p>Java代码 <a target="_blank" rel="noopener" href="http://zzqrj.iteye.com/blog/"><img src="http://zzqrj.iteye.com/images/icon_star.png" alt="收藏代码"></a></p>
<ol>
<li>public class ByteArrayStreamDemo {&amp;#160;2.  public static void main(String[] args) {&amp;#160;3.  try {&amp;#160;4.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; BufferedInputStream bufInputStream &#x3D; new BufferedInputStream(&amp;#160;5.  new FileInputStream(&quot;F:\read.txt&quot;));&amp;#160;6.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; ByteArrayOutputStream arrayOutputStream &#x3D; new ByteArrayOutputStream();&amp;#160;7.  byte[] bytes &#x3D; new byte[1];&amp;#160;8.  &#x2F;&#x2F; 将文件内容写入位数组流</li>
<li>while (bufInputStream.read(bytes) !&#x3D; -1) {&amp;#160;10.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; arrayOutputStream.write(bytes);&amp;#160;11.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }&amp;#160;12.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; arrayOutputStream.close();&amp;#160;13.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bufInputStream.close();&amp;#160;14.  &#x2F;&#x2F; toByteArray()方法，以字符方式显示位数组内容</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bytes &#x3D; arrayOutputStream.toByteArray();&amp;#160;16.  for (int i &#x3D; 0; i &lt; bytes.length; i++) {&amp;#160;17.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.print((char) bytes[i]);&amp;#160;18.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }&amp;#160;19.  &#x2F;&#x2F;toString()方法</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(arrayOutputStream.toString());&amp;#160;21.22.  &#x2F;&#x2F; writeTo方法</li>
<li>&#x2F;&#x2F;写到控制台输出流(能直接输出)</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; arrayOutputStream.writeTo(System.out);&amp;#160;&amp;#160;25.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; FileOutputStream fo&#x3D;new FileOutputStream(&quot;F:\saveFile.txt&quot;,true);&amp;#160;26.  &#x2F;&#x2F;写到文件输出流，能直接输出</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; arrayOutputStream.writeTo(fo);&amp;#160;28.29.  &#x2F;&#x2F; 让使用者输入位置与字符修改位数组内容</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; Scanner scanner &#x3D; new Scanner(System.in);&amp;#160;31.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.print(&quot;请输入修改位置：&quot;);&amp;#160;32.  int pos &#x3D; scanner.nextInt();&amp;#160;33.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(&quot;输入修改字符&quot;);&amp;#160;34.  &#x2F;&#x2F; 修改数组中对应的字符</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bytes[pos - 1] &#x3D; (byte) scanner.next().charAt(0);&amp;#160;36.  &#x2F;&#x2F; 将位数组内容存回文件</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; ByteArrayInputStream byteArrayInputStream &#x3D; new ByteArrayInputStream(&amp;#160;38.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bytes); &#x2F;&#x2F; 参数是数组</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; BufferedOutputStream bufOutputStream &#x3D; new BufferedOutputStream(&amp;#160;40.  new FileOutputStream(&quot;F:\read.txt&quot;));&amp;#160;41.  byte[] tmp &#x3D; new byte[1];&amp;#160;42.  while (byteArrayInputStream.read(tmp) !&#x3D; -1)&#x2F;&#x2F;从字节数组中读取数据</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bufOutputStream.write(tmp);&amp;#160;44.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; byteArrayInputStream.close();&amp;#160;45.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bufOutputStream.flush();&amp;#160;46.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bufOutputStream.close();&amp;#160;47.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } catch (ArrayIndexOutOfBoundsException e) {&amp;#160;48.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(&quot;请指定文件名称&quot;);&amp;#160;49.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } catch (IOException e) {&amp;#160;50.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; e.printStackTrace();&amp;#160;51.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }&amp;#160;52.  &amp;#160;&amp;#160;&amp;#160; }&amp;#160;53.  }&amp;#160;</li>
</ol>
<p>**CharArrayReader的方法： **<br>构造函数：CharArrayReader(char[] buf)创建一个 CharArrayReader，使用 buf 作为其缓冲区数组。<br>CharArrayReader (char[] buf, int offset, int length)<br>创建 CharArrayReader，使用 buf 作为其缓冲区数组。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160; buf - 输入缓冲区。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160; offset - 缓冲区中要读取的第一个char的偏移量。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160; length - 从缓冲区中读取的最字符数。<br>int read()读取单个字符<br>int read(char[] c)将最多 c.length 个字符读入到 char 数组中<br>c - 存储读取数据的缓冲区。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160; 返回：读取的实际字符数；如果到达流末尾，则返回 -1<br>int read(char[] c, int off,int len)读取len个字节到字节数组b中的指定位置<br>&amp;#160; c - 目标缓冲区。<br>&amp;#160;&amp;#160;&amp;#160;&amp;#160; off - 开始存储字符的偏移量。<br>len - 要读取的最大字符数。</p>
<p>**CharArrayWriter的方法： **<br>char[]&amp;#160; toCharArray() 返回输入数据的副本。<br>String toString() 将输入的数据转换为字符串。<br>void write(char[] b, int off, int len)<br>将char数组中从偏移量off开始的len个字节写入此CharArrayWriter数组输出。<br>c - 数据。<br>off - 数据的初始偏移量。<br>len - 要写入的字符数。<br>void write(String str, int off, int len) 将字符串的某一部分写入缓冲区。<br>str -要写入的字符串。<br>off - 数据的初始偏移量。<br>len - 要写入的字符数。<br>void write(int b) 将一个字符写入缓冲区。<br>void writeTo(Writer out) 将缓冲区的内容写入另一个字符流。</p>
<p>Java代码 <a target="_blank" rel="noopener" href="http://zzqrj.iteye.com/blog/"><img src="http://zzqrj.iteye.com/images/icon_star.png" alt="收藏代码"></a></p>
<ol>
<li>public class CharArrayReaderWriterDemo {&amp;#160;2.  public static void main(String[] args) {&amp;#160;3.  try {&amp;#160;4.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; BufferedReader bufInputReader &#x3D; new BufferedReader(new FileReader(&amp;#160;5.  &quot;F:\read.txt&quot;));&amp;#160;6.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; CharArrayWriter charArrayWriter &#x3D; new CharArrayWriter();&amp;#160;7.  char[] array &#x3D; new char[1];&amp;#160;8.  &#x2F;&#x2F; 将文件读入字符数组</li>
<li>while (bufInputReader.read(array) !&#x3D; -1) {&amp;#160;10.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; charArrayWriter.write(array);&amp;#160;11.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }&amp;#160;12.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; charArrayWriter.close();&amp;#160;13.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bufInputReader.close();&amp;#160;14.15.  &#x2F;&#x2F; toCharArray()方法 显示字符内容</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; array &#x3D; charArrayWriter.toCharArray();&amp;#160;17.  for (int i &#x3D; 0; i &lt; array.length; i++) {&amp;#160;18.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.print(array[i] + &quot; &quot;);&amp;#160;19.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }&amp;#160;20.  &#x2F;&#x2F;toString()方法</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(charArrayWriter.toString());&amp;#160;22.23.  &#x2F;&#x2F; writeTo方法&amp;#160; 写到文件输出流，能直接输出</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; FileWriter fw&#x3D;new FileWriter(&quot;F:\saveFile.txt&quot;);&amp;#160;25.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; charArrayWriter.writeTo(fw);&amp;#160;26.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; fw.close();&amp;#160;27.28.  &#x2F;&#x2F; 将字符数组内容存回文件</li>
<li>&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; CharArrayReader charArrayReader &#x3D; new CharArrayReader(array);&amp;#160;30.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; BufferedWriter bufWriter &#x3D; new BufferedWriter(new FileWriter(&quot;F:\read.txt&quot;));&amp;#160;31.  char[] tmp &#x3D; new char[1];&amp;#160;32.  while (charArrayReader.read(tmp) !&#x3D; -1) {&amp;#160;33.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bufWriter.write(tmp);&amp;#160;34.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }&amp;#160;35.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; charArrayReader.close();&amp;#160;36.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bufWriter.flush();&amp;#160;37.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; bufWriter.close();&amp;#160;38.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } catch (ArrayIndexOutOfBoundsException e) {&amp;#160;39.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; System.out.println(&quot;请指定文件名！&quot;);&amp;#160;40.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; } catch (IOException e) {&amp;#160;41.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; e.printStackTrace();&amp;#160;42.  &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; }&amp;#160;43.  &amp;#160;&amp;#160;&amp;#160; }&amp;#160;44.  }&amp;#160;</li>
</ol>
<p><strong>3. 其它</strong></p>
<p>InputStreamReader 和 OutputStreamWriter，用于字节流与字符流之间的转换<br>InputStreamReader从一个数据源读取字节，并自动将其转换成Unicode字符，除非特别声明<br>OutputStreamWriter将字符的Unicode编码写到输出流，如果你的使用的不是Unicode字符，OutputStreamWriter会将你的字符编码转换成Unicode编码。<br>在InputStreamReader和OutputStreamWriter的结尾链接一个BufferedReader和BufferedWriter是一个好主意。记住对BufferedWriter使用flush()方法。</p>
<p>&#x2F;&#x2F; 读写文件的编码：<br>InputStreamReader r &#x3D; new InputStreamReader(new FileInputStream(fileName), &quot;utf-8&quot;);<br>OutputStreamWriter out &#x3D; new OutputStreamWriter(new FileOutputStream(fileName),&quot;utf-8&quot;);</p>

    
  </div>

</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2012/11/23/java-e4-b8-ad-e9-81-8d-e5-8e-86map-e7-9a-84-e5-87-a0-e7-a7-8d-e6-96-b9-e6-b3-95/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2012/11/23/e5-b9-b4-e6-9c-ab-e7-94-b5-e5-bd-b1-e5-ad-a3/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              S
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              T
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              M
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
